# Definition of Ready (DoR) для задач команды

## Введение
Ниже — подробное объяснение каждого пункта Definition of Ready (DoR), привязанное к тому, что уже сделала ваша команда. Это не абстрактные правила, а конкретные критерии, которыми вы можете проверять задачи перед тем, как брать их в спринт.

---

## 1. Чётко сформулирована и описана в бэклоге
- **Что это значит:** Задача имеет однозначное название, краткое описание, привязку к конкретному use-case (UC1–UC9) и понятный скоуп работы.  
- **Как это у вас работает сейчас:**  
  - UC1–UC2 (Регистрация и вход): сформулированы с конкретными FR‑пунктами и закрыты.  
  - UC6 (Исключение ингредиентов): сформулировано и реализовано.  
  - UC9 (Избранное): есть описание, UI и сохранение в SQLite частично готовы.  
  - UC8 (Отзывы): описаны, но отложены; отмечены как технический долг.  
- **Как проверять перед спринтом:**  
  - Название: «UC5 — Загрузка фото ингредиентов: интеграция VLM».  
  - Описание: что делаем, где делаем (Frontend/Backend/Model Manager), что не делаем.  
  - Связь: ссылка на соответствующий FR‑пункт и экран UI.  
  - Границы: явно указано, что вне скоупа (например, без ретраев и очередей — в отдельной задаче).

---

## 2. Имеет понятный бизнес‑контекст (зачем нужна)
- **Что это значит:** В задаче объяснено, какую ценность она приносит пользователю/демо/MVP.  
- **Как это у вас работает сейчас:**  
  - UC1–UC2: дают доступ к функционалу, без них пользователь не может сохранять историю/избранное.  
  - UC6: повышает релевантность рецептов за счёт исключения нежелательных продуктов.  
  - UC5/UC7: обеспечивают основную ценность MVP — фото → ингредиенты → рецепт.  
- **Как формулировать контекст:**  
  - Ценность: «Задача нужна, чтобы пользователь получил рецепт из имеющихся продуктов».  
  - Риск без реализации: «Без этой задачи MVP не демонстрирует сквозной сценарий».  
  - Метрика успеха: «Пользователь доходит до экрана истории, где видит созданный рецепт».

---

## 3. Определены входные данные и ожидаемый результат
- **Что это значит:** Ясно, какие данные принимает и возвращает каждая часть задачи — на уровне API, базы и UI.  
- **Как это у вас работает сейчас:**  
  - UC1–UC2: вход — email/пароль; результат — авторизованный пользователь.  
  - UC6: вход — список ингредиентов + метки исключений; результат — обновлённый набор рецептов.  
  - UC9: вход — идентификатор рецепта; результат — запись в избранном (SQLite).  
- **Как фиксировать для новых задач:**  
  - UC5 (пример):  
    - Вход: файл JPEG/PNG до 10 MB, загруженный через UI; метаданные запроса (userId).  
    - Выход: список распознанных ингредиентов, сохранённый в истории (SQLite), статус операции в UI.  
  - UC7 (пример):  
    - Вход: выбранный рецепт из списка; параметры пользователя (ограничения из профиля).  
    - Выход: текстовый план приготовления, возможность отметить шаги.

---

## 4. Есть критерии приёмки (acceptance criteria)
- **Что это значит:** Чёткий список условий, при которых задача считается готовой; это ваш чек‑лист для тестирования.  
- **Как это у вас работает сейчас:**  
  - UC1–UC2: «Пользователь регистрируется и входит; ошибки отображаются; доступ к функционалу предоставляется».  
  - UC6: «Ингредиенты можно исключать; список рецептов обновляется; UI отражает изменения».  
- **Примеры критериев для ключевых задач:**  
  - UC5 — Распознавание ингредиентов:  
    - После загрузки фото UI показывает список ингредиентов.  
    - Если распознавание не удалось, UI предлагает загрузить другое фото.  
    - Распознанные ингредиенты доступны для исключения в UI.  
  - UC7 — Выбор рецепта:  
    - Пользователь видит список рецептов, может выбрать один.  
    - Отображается план приготовления в тексте; шаги можно отмечать.  
  - UC9 — Избранное:  
    - Рецепт добавляется в избранное; при ошибке — понятное сообщение.  
    - Список избранного доступен и соответствует данным из SQLite.

---

## 5. Нет блокирующих зависимостей или они явно зафиксированы
- **Что это значит:** Задача может быть выполнена в текущем спринте; если есть зависимость — она указана и учтена в планировании.  
- **Как это у вас работает сейчас:**  
  - Готово: UC1–UC2 и UC6 — независимы, можно использовать.  
  - С зависимостями: UC5/UC7 требуют связки RabbitMQ ↔ Model Manager ↔ VLM/LLM; это отражено в плане спринта.  
- **Как отмечать зависимости:**  
  - Технические: «Нужен работающий коннектор VLM/LLM и очередь RabbitMQ».  
  - Организационные: «Нужен макет UI и описание API в OpenAPI».  
  - Решение: если зависимость критична — разбиваем на подзадачи (например, «заглушка VLM», «интеграция VLM», «ретраи/ошибки»).

---

## 6. Оценена по трудоёмкости (story points или часы)
- **Что это значит:** Есть согласованная оценка сложности и времени, чтобы план спринта был реалистичным.  
- **Как это у вас работает сейчас:**  
  - UC1–UC2, UC6: фактически имеют оценку «готово».  
  - UC5, UC7, UC9: отмечены как «частично», требуют дополнительной интеграции.  
  - UC8: технический долг — вынесен за пределы MVP.  
- **Как оценивать новые задачи:**  
  - Метод: story points (например, 1–3–5–8) по сложности и рискам интеграции.  
  - Принцип: учитывать внешние зависимости (VLM/LLM), тесты, документацию.  
  - Результат: суммарная спринтовая ёмкость покрывает набор must‑have задач для MVP.

---

## Итог
- **Зачем вам DoR:** это ваш фильтр качества — в разработку попадают только понятные, полезные и проверяемые задачи, без скрытых блокеров.  
- **Как применять:** перед началом спринта пробегаться по чек‑листу для каждой задачи и не брать те, которые не проходят любой из пунктов (либо дополнять их до готовности).  
- **Что уже хорошо у вашей команды:** вы держите связь задач с UC/FR, указываете реальные технологии (HTML/JS, SQLite), и фиксируете статус «готово/частично/не реализовано» — это уже сильная база для зрелого планирования.
